name: Release Binaries

# Builds native binaries for every major platform and publishes them:
#   - push to main/develop  →  nightly pre-release (gitprint-nightly-main, gitprint-nightly-develop)
#   - push tag v*           →  versioned GitHub release with auto-generated notes

on:
  push:
    branches: [main, develop]
    tags: ['v*']

# Cancel any in-progress run for the same ref so pushes don't pile up.
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  # ── Benchmark regression gate ─────────────────────────────────────────────────
  # Only runs for tag pushes. Branch pushes to main already go through the
  # benchmark job in ci.yml, so re-running here would duplicate effort.
  # Skipped jobs count as success in GitHub Actions, so publish still runs
  # for nightly branch releases without waiting for this job.
  benchmark:
    name: Benchmark regression check
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    env:
      REGRESSION_THRESHOLD: "20"
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
        with:
          key: release-bench

      # Restore the latest main-branch baseline produced by ci.yml.
      # Exact-key match won't hit for tag SHAs; prefix fallback finds the
      # most recent baseline saved from a main-branch run.
      - name: Restore benchmark baseline
        uses: actions/cache/restore@v4
        with:
          path: bench-baseline
          key: bench-baseline-${{ github.sha }}
          restore-keys: bench-baseline-

      - name: Run benchmarks
        run: cargo bench --bench pipeline -- --save-baseline current

      - name: Check for performance regressions
        run: python3 scripts/check_benchmarks.py

  # ── Build ────────────────────────────────────────────────────────────────────
  build:
    name: Build · ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux glibc — preferred by binstall on mainstream distros; uses glibc's fast allocator
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            cross: false

          # Linux musl — statically linked, runs on Alpine / musl-based distros
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
            cross: false

          - target: aarch64-unknown-linux-musl
            os: ubuntu-latest
            cross: true   # cross-compiled via the `cross` Docker toolchain

          # macOS ARM (macos-14+ runner is ARM64)
          - target: aarch64-apple-darwin
            os: macos-latest
            cross: false

          # Windows
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            cross: false

    steps:
      - uses: actions/checkout@v4

      # Toolchain version comes from rust-toolchain.toml; targets are per-matrix.
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      # Belt-and-suspenders: ensure the target stdlib is installed even on a cold
      # tool-cache (e.g. after a version bump in rust-toolchain.toml). cross builds
      # use their own Docker image so only native builds need this.
      - name: Ensure Rust target stdlib is installed
        if: "!matrix.cross"
        run: rustup target add ${{ matrix.target }}

      - uses: Swatinem/rust-cache@v2
        with:
          key: release-${{ matrix.target }}

      # musl-tools provides musl-gcc required for the x86_64-musl target.
      - name: Install musl toolchain
        if: contains(matrix.target, 'musl') && !matrix.cross
        run: sudo apt-get install -y musl-tools

      # taiki-e/install-action downloads pre-built cross binaries — much faster than
      # compiling from source with `cargo install cross`.
      - name: Install cross
        if: matrix.cross
        uses: taiki-e/install-action@v2
        with:
          tool: cross

      - name: Build
        shell: bash
        env:
          # Explicitly reinforce all profile.release optimizations from Cargo.toml so
          # they can't be silently overridden by toolchain defaults or stale cache.
          CARGO_PROFILE_RELEASE_LTO: fat
          CARGO_PROFILE_RELEASE_CODEGEN_UNITS: "1"
          CARGO_PROFILE_RELEASE_OPT_LEVEL: "3"
          CARGO_PROFILE_RELEASE_PANIC: abort
          CARGO_PROFILE_RELEASE_STRIP: symbols
        run: |
          if [[ "${{ matrix.cross }}" == "true" ]]; then
            cross build --release --target ${{ matrix.target }}
          else
            cargo build --release --target ${{ matrix.target }}
          fi

      - name: Package (Unix)
        if: runner.os != 'Windows'
        run: >
          tar czf gitprint-${{ matrix.target }}.tar.gz
          -C target/${{ matrix.target }}/release gitprint

      - name: Package (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: >
          Compress-Archive
          -Path   target/${{ matrix.target }}/release/gitprint.exe
          -DestinationPath gitprint-${{ matrix.target }}.zip

      - uses: actions/upload-artifact@v4
        with:
          name: gitprint-${{ matrix.target }}
          # Each job uploads exactly one archive; glob picks whichever extension was created.
          path: gitprint-${{ matrix.target }}.*

  # ── Docker image (versioned tags only) ───────────────────────────────────────
  # Publishes ghcr.io/izelnakri/gitprint:<version>, <major>.<minor>, and latest.
  # Nightly Docker images (pushed on every main-branch commit) are handled by
  # ci.yml's package job — no duplication needed here for branch pushes.
  package:
    name: Publish Docker image
    if: startsWith(github.ref, 'refs/tags/')
    needs: [benchmark]
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Derives: v0.3.4  →  tags 0.3.4, 0.3, and latest.
      - uses: docker/metadata-action@v5
        id: meta
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest

      - uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ── Publish ──────────────────────────────────────────────────────────────────
  publish:
    name: Publish release
    needs: [build, benchmark]
    runs-on: ubuntu-latest
    permissions:
      contents: write   # required to create/delete GitHub releases and tags

    steps:
      # Needed to resolve `git log` for the nightly release description.
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # Download all platform archives into a single directory.
      - uses: actions/download-artifact@v4
        with:
          merge-multiple: true
          path: artifacts

      - name: Generate SHA-256 checksums
        run: cd artifacts && sha256sum * > checksums.txt

      # ── Tagged release (e.g. v1.2.3) ────────────────────────────────────────
      # make release creates the GitHub Release entry locally (with CHANGELOG notes)
      # before pushing the tag, so CI only needs to upload the built artifacts.
      # The create fallback handles the rare case where CI wins the race.
      - name: Upload artifacts to versioned release
        if: startsWith(github.ref, 'refs/tags/')
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
        run: |
          gh release create "${{ github.ref_name }}" \
            --title "${{ github.ref_name }}" \
            --generate-notes 2>/dev/null || true
          gh release upload "${{ github.ref_name }}" --clobber artifacts/*

      # ── Nightly pre-release (branch push) ───────────────────────────────────
      # The tag is derived from the branch name so main and develop get
      # independent rolling releases: nightly-main, nightly-develop, etc.
      - name: Publish nightly pre-release
        if: "!startsWith(github.ref, 'refs/tags/')"
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          BRANCH="${GITHUB_REF#refs/heads/}"
          TAG="nightly-${BRANCH//\//-}"

          # Delete the previous nightly for this branch (tag + release) and recreate
          # atomically so users always find a single up-to-date entry.
          gh release delete "$TAG" --yes --cleanup-tag 2>/dev/null || true

          {
            printf 'Automated development build from the `%s` branch.\n\n' "$BRANCH"
            printf '> **Not recommended for production use.**\n\n'
            printf '| | |\n|---|---|\n'
            printf '| **Commit** | `%s` |\n' "${{ github.sha }}"
            printf '| **Message** | %s |\n' "$COMMIT_MSG"
          } > /tmp/notes.md

          gh release create "$TAG" \
            --prerelease \
            --title "nightly ($BRANCH)" \
            --notes-file /tmp/notes.md \
            artifacts/*
